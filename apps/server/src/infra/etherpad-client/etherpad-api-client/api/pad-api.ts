/* tslint:disable */
/* eslint-disable */
/**
 * Etherpad API
 * Etherpad is a real-time collaborative editor scalable to thousands of simultaneous real time users. It provides full data export capabilities, and runs on your server, under your control.
 *
 * The version of the OpenAPI document: 1.3.0
 * Contact: support@example.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { CreateDiffHTMLUsingGET200Response } from '../models';
// @ts-ignore
import type { CreateGroupUsingGET400Response } from '../models';
// @ts-ignore
import type { CreateGroupUsingGET401Response } from '../models';
// @ts-ignore
import type { CreateGroupUsingGET500Response } from '../models';
// @ts-ignore
import type { DeleteGroupUsingGET200Response } from '../models';
// @ts-ignore
import type { GetChatHeadUsingGET200Response } from '../models';
// @ts-ignore
import type { GetChatHistoryUsingGET200Response } from '../models';
// @ts-ignore
import type { GetHTMLUsingGET200Response } from '../models';
// @ts-ignore
import type { GetLastEditedUsingGET200Response } from '../models';
// @ts-ignore
import type { GetPublicStatusUsingGET200Response } from '../models';
// @ts-ignore
import type { GetReadOnlyIDUsingGET200Response } from '../models';
// @ts-ignore
import type { GetRevisionsCountUsingGET200Response } from '../models';
// @ts-ignore
import type { GetTextUsingGET200Response } from '../models';
// @ts-ignore
import type { ListAuthorsOfPadUsingGET200Response } from '../models';
// @ts-ignore
import type { ListPadsUsingGET200Response } from '../models';
// @ts-ignore
import type { PadUsersCountUsingGET200Response } from '../models';
// @ts-ignore
import type { PadUsersUsingGET200Response } from '../models';
/**
 * PadApi - axios parameter creator
 * @export
 */
export const PadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary appends a chat message
         * @param {string} [padID] 
         * @param {string} [text] 
         * @param {string} [authorID] 
         * @param {string} [time] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appendChatMessageUsingGET: async (padID?: string, text?: string, authorID?: string, time?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/appendChatMessage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (authorID !== undefined) {
                localVarQueryParameter['authorID'] = authorID;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary appends a chat message
         * @param {string} [padID] 
         * @param {string} [text] 
         * @param {string} [authorID] 
         * @param {string} [time] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appendChatMessageUsingPOST: async (padID?: string, text?: string, authorID?: string, time?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/appendChatMessage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (authorID !== undefined) {
                localVarQueryParameter['authorID'] = authorID;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns ok when the current api token is valid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkTokenUsingGET: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/checkToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns ok when the current api token is valid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkTokenUsingPOST: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/checkToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} [padID] 
         * @param {string} [startRev] 
         * @param {string} [endRev] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiffHTMLUsingGET: async (padID?: string, startRev?: string, endRev?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/createDiffHTML`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }

            if (startRev !== undefined) {
                localVarQueryParameter['startRev'] = startRev;
            }

            if (endRev !== undefined) {
                localVarQueryParameter['endRev'] = endRev;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} [padID] 
         * @param {string} [startRev] 
         * @param {string} [endRev] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiffHTMLUsingPOST: async (padID?: string, startRev?: string, endRev?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/createDiffHTML`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }

            if (startRev !== undefined) {
                localVarQueryParameter['startRev'] = startRev;
            }

            if (endRev !== undefined) {
                localVarQueryParameter['endRev'] = endRev;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * creates a new (non-group) pad. Note that if you need to create a group Pad, you should call createGroupPad
         * @param {string} [padID] 
         * @param {string} [text] 
         * @param {string} [authorId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPadUsingGET: async (padID?: string, text?: string, authorId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/createPad`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (authorId !== undefined) {
                localVarQueryParameter['authorId'] = authorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * creates a new (non-group) pad. Note that if you need to create a group Pad, you should call createGroupPad
         * @param {string} [padID] 
         * @param {string} [text] 
         * @param {string} [authorId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPadUsingPOST: async (padID?: string, text?: string, authorId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/createPad`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (authorId !== undefined) {
                localVarQueryParameter['authorId'] = authorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deletes a pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePadUsingGET: async (padID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deletePad`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deletes a pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePadUsingPOST: async (padID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deletePad`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the chatHead (chat-message) of the pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatHeadUsingGET: async (padID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getChatHead`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the chatHead (chat-message) of the pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatHeadUsingPOST: async (padID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getChatHead`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the chat history
         * @param {string} [padID] 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatHistoryUsingGET: async (padID?: string, start?: string, end?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getChatHistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the chat history
         * @param {string} [padID] 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatHistoryUsingPOST: async (padID?: string, start?: string, end?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getChatHistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the text of a pad formatted as HTML
         * @param {string} [padID] 
         * @param {string} [rev] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHTMLUsingGET: async (padID?: string, rev?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getHTML`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }

            if (rev !== undefined) {
                localVarQueryParameter['rev'] = rev;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the text of a pad formatted as HTML
         * @param {string} [padID] 
         * @param {string} [rev] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHTMLUsingPOST: async (padID?: string, rev?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getHTML`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }

            if (rev !== undefined) {
                localVarQueryParameter['rev'] = rev;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the timestamp of the last revision of the pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastEditedUsingGET: async (padID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getLastEdited`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the timestamp of the last revision of the pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastEditedUsingPOST: async (padID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getLastEdited`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary return true of false
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicStatusUsingGET: async (padID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getPublicStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary return true of false
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicStatusUsingPOST: async (padID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getPublicStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the read only link of a pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReadOnlyIDUsingGET: async (padID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getReadOnlyID`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the read only link of a pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReadOnlyIDUsingPOST: async (padID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getReadOnlyID`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the number of revisions of this pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRevisionsCountUsingGET: async (padID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getRevisionsCount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the number of revisions of this pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRevisionsCountUsingPOST: async (padID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getRevisionsCount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the text of a pad
         * @param {string} [padID] 
         * @param {string} [rev] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTextUsingGET: async (padID?: string, rev?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getText`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }

            if (rev !== undefined) {
                localVarQueryParameter['rev'] = rev;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the text of a pad
         * @param {string} [padID] 
         * @param {string} [rev] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTextUsingPOST: async (padID?: string, rev?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getText`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }

            if (rev !== undefined) {
                localVarQueryParameter['rev'] = rev;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list all the pads
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllPadsUsingGET: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/listAllPads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list all the pads
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllPadsUsingPOST: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/listAllPads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns an array of authors who contributed to this pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAuthorsOfPadUsingGET: async (padID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/listAuthorsOfPad`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns an array of authors who contributed to this pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAuthorsOfPadUsingPOST: async (padID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/listAuthorsOfPad`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the number of user that are currently editing this pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        padUsersCountUsingGET: async (padID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/padUsersCount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the number of user that are currently editing this pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        padUsersCountUsingPOST: async (padID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/padUsersCount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the list of users that are currently editing this pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        padUsersUsingGET: async (padID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/padUsers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the list of users that are currently editing this pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        padUsersUsingPOST: async (padID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/padUsers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary sends a custom message of type msg to the pad
         * @param {string} [padID] 
         * @param {string} [msg] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendClientsMessageUsingGET: async (padID?: string, msg?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sendClientsMessage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }

            if (msg !== undefined) {
                localVarQueryParameter['msg'] = msg;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary sends a custom message of type msg to the pad
         * @param {string} [padID] 
         * @param {string} [msg] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendClientsMessageUsingPOST: async (padID?: string, msg?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sendClientsMessage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }

            if (msg !== undefined) {
                localVarQueryParameter['msg'] = msg;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary sets the text of a pad with HTML
         * @param {string} [padID] 
         * @param {string} [html] 
         * @param {string} [authorId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setHTMLUsingGET: async (padID?: string, html?: string, authorId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/setHTML`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }

            if (html !== undefined) {
                localVarQueryParameter['html'] = html;
            }

            if (authorId !== undefined) {
                localVarQueryParameter['authorId'] = authorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary sets the text of a pad with HTML
         * @param {string} [padID] 
         * @param {string} [html] 
         * @param {string} [authorId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setHTMLUsingPOST: async (padID?: string, html?: string, authorId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/setHTML`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }

            if (html !== undefined) {
                localVarQueryParameter['html'] = html;
            }

            if (authorId !== undefined) {
                localVarQueryParameter['authorId'] = authorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary sets a boolean for the public status of a pad
         * @param {string} [padID] 
         * @param {string} [publicStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPublicStatusUsingGET: async (padID?: string, publicStatus?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/setPublicStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }

            if (publicStatus !== undefined) {
                localVarQueryParameter['publicStatus'] = publicStatus;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary sets a boolean for the public status of a pad
         * @param {string} [padID] 
         * @param {string} [publicStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPublicStatusUsingPOST: async (padID?: string, publicStatus?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/setPublicStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }

            if (publicStatus !== undefined) {
                localVarQueryParameter['publicStatus'] = publicStatus;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary sets the text of a pad
         * @param {string} [padID] 
         * @param {string} [text] 
         * @param {string} [authorId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTextUsingGET: async (padID?: string, text?: string, authorId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/setText`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (authorId !== undefined) {
                localVarQueryParameter['authorId'] = authorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary sets the text of a pad
         * @param {string} [padID] 
         * @param {string} [text] 
         * @param {string} [authorId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTextUsingPOST: async (padID?: string, text?: string, authorId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/setText`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            if (padID !== undefined) {
                localVarQueryParameter['padID'] = padID;
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (authorId !== undefined) {
                localVarQueryParameter['authorId'] = authorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PadApi - functional programming interface
 * @export
 */
export const PadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PadApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary appends a chat message
         * @param {string} [padID] 
         * @param {string} [text] 
         * @param {string} [authorID] 
         * @param {string} [time] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appendChatMessageUsingGET(padID?: string, text?: string, authorID?: string, time?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteGroupUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appendChatMessageUsingGET(padID, text, authorID, time, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.appendChatMessageUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary appends a chat message
         * @param {string} [padID] 
         * @param {string} [text] 
         * @param {string} [authorID] 
         * @param {string} [time] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appendChatMessageUsingPOST(padID?: string, text?: string, authorID?: string, time?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteGroupUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appendChatMessageUsingPOST(padID, text, authorID, time, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.appendChatMessageUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary returns ok when the current api token is valid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkTokenUsingGET(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteGroupUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkTokenUsingGET(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.checkTokenUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary returns ok when the current api token is valid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkTokenUsingPOST(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteGroupUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkTokenUsingPOST(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.checkTokenUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} [padID] 
         * @param {string} [startRev] 
         * @param {string} [endRev] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDiffHTMLUsingGET(padID?: string, startRev?: string, endRev?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDiffHTMLUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDiffHTMLUsingGET(padID, startRev, endRev, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.createDiffHTMLUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} [padID] 
         * @param {string} [startRev] 
         * @param {string} [endRev] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDiffHTMLUsingPOST(padID?: string, startRev?: string, endRev?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDiffHTMLUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDiffHTMLUsingPOST(padID, startRev, endRev, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.createDiffHTMLUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * creates a new (non-group) pad. Note that if you need to create a group Pad, you should call createGroupPad
         * @param {string} [padID] 
         * @param {string} [text] 
         * @param {string} [authorId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPadUsingGET(padID?: string, text?: string, authorId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteGroupUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPadUsingGET(padID, text, authorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.createPadUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * creates a new (non-group) pad. Note that if you need to create a group Pad, you should call createGroupPad
         * @param {string} [padID] 
         * @param {string} [text] 
         * @param {string} [authorId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPadUsingPOST(padID?: string, text?: string, authorId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteGroupUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPadUsingPOST(padID, text, authorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.createPadUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deletes a pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePadUsingGET(padID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteGroupUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePadUsingGET(padID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.deletePadUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deletes a pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePadUsingPOST(padID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteGroupUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePadUsingPOST(padID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.deletePadUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary returns the chatHead (chat-message) of the pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChatHeadUsingGET(padID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChatHeadUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChatHeadUsingGET(padID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.getChatHeadUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary returns the chatHead (chat-message) of the pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChatHeadUsingPOST(padID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChatHeadUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChatHeadUsingPOST(padID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.getChatHeadUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary returns the chat history
         * @param {string} [padID] 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChatHistoryUsingGET(padID?: string, start?: string, end?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChatHistoryUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChatHistoryUsingGET(padID, start, end, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.getChatHistoryUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary returns the chat history
         * @param {string} [padID] 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChatHistoryUsingPOST(padID?: string, start?: string, end?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChatHistoryUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChatHistoryUsingPOST(padID, start, end, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.getChatHistoryUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary returns the text of a pad formatted as HTML
         * @param {string} [padID] 
         * @param {string} [rev] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHTMLUsingGET(padID?: string, rev?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetHTMLUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHTMLUsingGET(padID, rev, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.getHTMLUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary returns the text of a pad formatted as HTML
         * @param {string} [padID] 
         * @param {string} [rev] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHTMLUsingPOST(padID?: string, rev?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetHTMLUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHTMLUsingPOST(padID, rev, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.getHTMLUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary returns the timestamp of the last revision of the pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLastEditedUsingGET(padID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLastEditedUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLastEditedUsingGET(padID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.getLastEditedUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary returns the timestamp of the last revision of the pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLastEditedUsingPOST(padID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLastEditedUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLastEditedUsingPOST(padID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.getLastEditedUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary return true of false
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicStatusUsingGET(padID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPublicStatusUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicStatusUsingGET(padID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.getPublicStatusUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary return true of false
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicStatusUsingPOST(padID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPublicStatusUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicStatusUsingPOST(padID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.getPublicStatusUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary returns the read only link of a pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReadOnlyIDUsingGET(padID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetReadOnlyIDUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReadOnlyIDUsingGET(padID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.getReadOnlyIDUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary returns the read only link of a pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReadOnlyIDUsingPOST(padID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetReadOnlyIDUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReadOnlyIDUsingPOST(padID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.getReadOnlyIDUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary returns the number of revisions of this pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRevisionsCountUsingGET(padID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRevisionsCountUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRevisionsCountUsingGET(padID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.getRevisionsCountUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary returns the number of revisions of this pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRevisionsCountUsingPOST(padID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRevisionsCountUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRevisionsCountUsingPOST(padID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.getRevisionsCountUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary returns the text of a pad
         * @param {string} [padID] 
         * @param {string} [rev] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTextUsingGET(padID?: string, rev?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTextUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTextUsingGET(padID, rev, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.getTextUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary returns the text of a pad
         * @param {string} [padID] 
         * @param {string} [rev] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTextUsingPOST(padID?: string, rev?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTextUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTextUsingPOST(padID, rev, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.getTextUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary list all the pads
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllPadsUsingGET(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPadsUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllPadsUsingGET(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.listAllPadsUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary list all the pads
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllPadsUsingPOST(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPadsUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllPadsUsingPOST(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.listAllPadsUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary returns an array of authors who contributed to this pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAuthorsOfPadUsingGET(padID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAuthorsOfPadUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAuthorsOfPadUsingGET(padID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.listAuthorsOfPadUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary returns an array of authors who contributed to this pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAuthorsOfPadUsingPOST(padID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAuthorsOfPadUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAuthorsOfPadUsingPOST(padID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.listAuthorsOfPadUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary returns the number of user that are currently editing this pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async padUsersCountUsingGET(padID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PadUsersCountUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.padUsersCountUsingGET(padID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.padUsersCountUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary returns the number of user that are currently editing this pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async padUsersCountUsingPOST(padID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PadUsersCountUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.padUsersCountUsingPOST(padID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.padUsersCountUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary returns the list of users that are currently editing this pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async padUsersUsingGET(padID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PadUsersUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.padUsersUsingGET(padID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.padUsersUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary returns the list of users that are currently editing this pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async padUsersUsingPOST(padID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PadUsersUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.padUsersUsingPOST(padID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.padUsersUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary sends a custom message of type msg to the pad
         * @param {string} [padID] 
         * @param {string} [msg] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendClientsMessageUsingGET(padID?: string, msg?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteGroupUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendClientsMessageUsingGET(padID, msg, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.sendClientsMessageUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary sends a custom message of type msg to the pad
         * @param {string} [padID] 
         * @param {string} [msg] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendClientsMessageUsingPOST(padID?: string, msg?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteGroupUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendClientsMessageUsingPOST(padID, msg, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.sendClientsMessageUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary sets the text of a pad with HTML
         * @param {string} [padID] 
         * @param {string} [html] 
         * @param {string} [authorId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setHTMLUsingGET(padID?: string, html?: string, authorId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteGroupUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setHTMLUsingGET(padID, html, authorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.setHTMLUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary sets the text of a pad with HTML
         * @param {string} [padID] 
         * @param {string} [html] 
         * @param {string} [authorId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setHTMLUsingPOST(padID?: string, html?: string, authorId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteGroupUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setHTMLUsingPOST(padID, html, authorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.setHTMLUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary sets a boolean for the public status of a pad
         * @param {string} [padID] 
         * @param {string} [publicStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPublicStatusUsingGET(padID?: string, publicStatus?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteGroupUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPublicStatusUsingGET(padID, publicStatus, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.setPublicStatusUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary sets a boolean for the public status of a pad
         * @param {string} [padID] 
         * @param {string} [publicStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPublicStatusUsingPOST(padID?: string, publicStatus?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteGroupUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPublicStatusUsingPOST(padID, publicStatus, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.setPublicStatusUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary sets the text of a pad
         * @param {string} [padID] 
         * @param {string} [text] 
         * @param {string} [authorId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTextUsingGET(padID?: string, text?: string, authorId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteGroupUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTextUsingGET(padID, text, authorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.setTextUsingGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary sets the text of a pad
         * @param {string} [padID] 
         * @param {string} [text] 
         * @param {string} [authorId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTextUsingPOST(padID?: string, text?: string, authorId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteGroupUsingGET200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTextUsingPOST(padID, text, authorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PadApi.setTextUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PadApi - factory interface
 * @export
 */
export const PadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PadApiFp(configuration)
    return {
        /**
         * 
         * @summary appends a chat message
         * @param {string} [padID] 
         * @param {string} [text] 
         * @param {string} [authorID] 
         * @param {string} [time] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appendChatMessageUsingGET(padID?: string, text?: string, authorID?: string, time?: string, options?: any): AxiosPromise<DeleteGroupUsingGET200Response> {
            return localVarFp.appendChatMessageUsingGET(padID, text, authorID, time, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary appends a chat message
         * @param {string} [padID] 
         * @param {string} [text] 
         * @param {string} [authorID] 
         * @param {string} [time] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appendChatMessageUsingPOST(padID?: string, text?: string, authorID?: string, time?: string, options?: any): AxiosPromise<DeleteGroupUsingGET200Response> {
            return localVarFp.appendChatMessageUsingPOST(padID, text, authorID, time, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns ok when the current api token is valid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkTokenUsingGET(options?: any): AxiosPromise<DeleteGroupUsingGET200Response> {
            return localVarFp.checkTokenUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns ok when the current api token is valid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkTokenUsingPOST(options?: any): AxiosPromise<DeleteGroupUsingGET200Response> {
            return localVarFp.checkTokenUsingPOST(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} [padID] 
         * @param {string} [startRev] 
         * @param {string} [endRev] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiffHTMLUsingGET(padID?: string, startRev?: string, endRev?: string, options?: any): AxiosPromise<CreateDiffHTMLUsingGET200Response> {
            return localVarFp.createDiffHTMLUsingGET(padID, startRev, endRev, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} [padID] 
         * @param {string} [startRev] 
         * @param {string} [endRev] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiffHTMLUsingPOST(padID?: string, startRev?: string, endRev?: string, options?: any): AxiosPromise<CreateDiffHTMLUsingGET200Response> {
            return localVarFp.createDiffHTMLUsingPOST(padID, startRev, endRev, options).then((request) => request(axios, basePath));
        },
        /**
         * creates a new (non-group) pad. Note that if you need to create a group Pad, you should call createGroupPad
         * @param {string} [padID] 
         * @param {string} [text] 
         * @param {string} [authorId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPadUsingGET(padID?: string, text?: string, authorId?: string, options?: any): AxiosPromise<DeleteGroupUsingGET200Response> {
            return localVarFp.createPadUsingGET(padID, text, authorId, options).then((request) => request(axios, basePath));
        },
        /**
         * creates a new (non-group) pad. Note that if you need to create a group Pad, you should call createGroupPad
         * @param {string} [padID] 
         * @param {string} [text] 
         * @param {string} [authorId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPadUsingPOST(padID?: string, text?: string, authorId?: string, options?: any): AxiosPromise<DeleteGroupUsingGET200Response> {
            return localVarFp.createPadUsingPOST(padID, text, authorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deletes a pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePadUsingGET(padID?: string, options?: any): AxiosPromise<DeleteGroupUsingGET200Response> {
            return localVarFp.deletePadUsingGET(padID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deletes a pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePadUsingPOST(padID?: string, options?: any): AxiosPromise<DeleteGroupUsingGET200Response> {
            return localVarFp.deletePadUsingPOST(padID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the chatHead (chat-message) of the pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatHeadUsingGET(padID?: string, options?: any): AxiosPromise<GetChatHeadUsingGET200Response> {
            return localVarFp.getChatHeadUsingGET(padID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the chatHead (chat-message) of the pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatHeadUsingPOST(padID?: string, options?: any): AxiosPromise<GetChatHeadUsingGET200Response> {
            return localVarFp.getChatHeadUsingPOST(padID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the chat history
         * @param {string} [padID] 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatHistoryUsingGET(padID?: string, start?: string, end?: string, options?: any): AxiosPromise<GetChatHistoryUsingGET200Response> {
            return localVarFp.getChatHistoryUsingGET(padID, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the chat history
         * @param {string} [padID] 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatHistoryUsingPOST(padID?: string, start?: string, end?: string, options?: any): AxiosPromise<GetChatHistoryUsingGET200Response> {
            return localVarFp.getChatHistoryUsingPOST(padID, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the text of a pad formatted as HTML
         * @param {string} [padID] 
         * @param {string} [rev] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHTMLUsingGET(padID?: string, rev?: string, options?: any): AxiosPromise<GetHTMLUsingGET200Response> {
            return localVarFp.getHTMLUsingGET(padID, rev, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the text of a pad formatted as HTML
         * @param {string} [padID] 
         * @param {string} [rev] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHTMLUsingPOST(padID?: string, rev?: string, options?: any): AxiosPromise<GetHTMLUsingGET200Response> {
            return localVarFp.getHTMLUsingPOST(padID, rev, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the timestamp of the last revision of the pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastEditedUsingGET(padID?: string, options?: any): AxiosPromise<GetLastEditedUsingGET200Response> {
            return localVarFp.getLastEditedUsingGET(padID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the timestamp of the last revision of the pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastEditedUsingPOST(padID?: string, options?: any): AxiosPromise<GetLastEditedUsingGET200Response> {
            return localVarFp.getLastEditedUsingPOST(padID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary return true of false
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicStatusUsingGET(padID?: string, options?: any): AxiosPromise<GetPublicStatusUsingGET200Response> {
            return localVarFp.getPublicStatusUsingGET(padID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary return true of false
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicStatusUsingPOST(padID?: string, options?: any): AxiosPromise<GetPublicStatusUsingGET200Response> {
            return localVarFp.getPublicStatusUsingPOST(padID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the read only link of a pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReadOnlyIDUsingGET(padID?: string, options?: any): AxiosPromise<GetReadOnlyIDUsingGET200Response> {
            return localVarFp.getReadOnlyIDUsingGET(padID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the read only link of a pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReadOnlyIDUsingPOST(padID?: string, options?: any): AxiosPromise<GetReadOnlyIDUsingGET200Response> {
            return localVarFp.getReadOnlyIDUsingPOST(padID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the number of revisions of this pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRevisionsCountUsingGET(padID?: string, options?: any): AxiosPromise<GetRevisionsCountUsingGET200Response> {
            return localVarFp.getRevisionsCountUsingGET(padID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the number of revisions of this pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRevisionsCountUsingPOST(padID?: string, options?: any): AxiosPromise<GetRevisionsCountUsingGET200Response> {
            return localVarFp.getRevisionsCountUsingPOST(padID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the text of a pad
         * @param {string} [padID] 
         * @param {string} [rev] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTextUsingGET(padID?: string, rev?: string, options?: any): AxiosPromise<GetTextUsingGET200Response> {
            return localVarFp.getTextUsingGET(padID, rev, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the text of a pad
         * @param {string} [padID] 
         * @param {string} [rev] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTextUsingPOST(padID?: string, rev?: string, options?: any): AxiosPromise<GetTextUsingGET200Response> {
            return localVarFp.getTextUsingPOST(padID, rev, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary list all the pads
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllPadsUsingGET(options?: any): AxiosPromise<ListPadsUsingGET200Response> {
            return localVarFp.listAllPadsUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary list all the pads
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllPadsUsingPOST(options?: any): AxiosPromise<ListPadsUsingGET200Response> {
            return localVarFp.listAllPadsUsingPOST(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns an array of authors who contributed to this pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAuthorsOfPadUsingGET(padID?: string, options?: any): AxiosPromise<ListAuthorsOfPadUsingGET200Response> {
            return localVarFp.listAuthorsOfPadUsingGET(padID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns an array of authors who contributed to this pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAuthorsOfPadUsingPOST(padID?: string, options?: any): AxiosPromise<ListAuthorsOfPadUsingGET200Response> {
            return localVarFp.listAuthorsOfPadUsingPOST(padID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the number of user that are currently editing this pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        padUsersCountUsingGET(padID?: string, options?: any): AxiosPromise<PadUsersCountUsingGET200Response> {
            return localVarFp.padUsersCountUsingGET(padID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the number of user that are currently editing this pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        padUsersCountUsingPOST(padID?: string, options?: any): AxiosPromise<PadUsersCountUsingGET200Response> {
            return localVarFp.padUsersCountUsingPOST(padID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the list of users that are currently editing this pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        padUsersUsingGET(padID?: string, options?: any): AxiosPromise<PadUsersUsingGET200Response> {
            return localVarFp.padUsersUsingGET(padID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the list of users that are currently editing this pad
         * @param {string} [padID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        padUsersUsingPOST(padID?: string, options?: any): AxiosPromise<PadUsersUsingGET200Response> {
            return localVarFp.padUsersUsingPOST(padID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary sends a custom message of type msg to the pad
         * @param {string} [padID] 
         * @param {string} [msg] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendClientsMessageUsingGET(padID?: string, msg?: string, options?: any): AxiosPromise<DeleteGroupUsingGET200Response> {
            return localVarFp.sendClientsMessageUsingGET(padID, msg, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary sends a custom message of type msg to the pad
         * @param {string} [padID] 
         * @param {string} [msg] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendClientsMessageUsingPOST(padID?: string, msg?: string, options?: any): AxiosPromise<DeleteGroupUsingGET200Response> {
            return localVarFp.sendClientsMessageUsingPOST(padID, msg, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary sets the text of a pad with HTML
         * @param {string} [padID] 
         * @param {string} [html] 
         * @param {string} [authorId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setHTMLUsingGET(padID?: string, html?: string, authorId?: string, options?: any): AxiosPromise<DeleteGroupUsingGET200Response> {
            return localVarFp.setHTMLUsingGET(padID, html, authorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary sets the text of a pad with HTML
         * @param {string} [padID] 
         * @param {string} [html] 
         * @param {string} [authorId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setHTMLUsingPOST(padID?: string, html?: string, authorId?: string, options?: any): AxiosPromise<DeleteGroupUsingGET200Response> {
            return localVarFp.setHTMLUsingPOST(padID, html, authorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary sets a boolean for the public status of a pad
         * @param {string} [padID] 
         * @param {string} [publicStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPublicStatusUsingGET(padID?: string, publicStatus?: string, options?: any): AxiosPromise<DeleteGroupUsingGET200Response> {
            return localVarFp.setPublicStatusUsingGET(padID, publicStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary sets a boolean for the public status of a pad
         * @param {string} [padID] 
         * @param {string} [publicStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPublicStatusUsingPOST(padID?: string, publicStatus?: string, options?: any): AxiosPromise<DeleteGroupUsingGET200Response> {
            return localVarFp.setPublicStatusUsingPOST(padID, publicStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary sets the text of a pad
         * @param {string} [padID] 
         * @param {string} [text] 
         * @param {string} [authorId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTextUsingGET(padID?: string, text?: string, authorId?: string, options?: any): AxiosPromise<DeleteGroupUsingGET200Response> {
            return localVarFp.setTextUsingGET(padID, text, authorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary sets the text of a pad
         * @param {string} [padID] 
         * @param {string} [text] 
         * @param {string} [authorId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTextUsingPOST(padID?: string, text?: string, authorId?: string, options?: any): AxiosPromise<DeleteGroupUsingGET200Response> {
            return localVarFp.setTextUsingPOST(padID, text, authorId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PadApi - interface
 * @export
 * @interface PadApi
 */
export interface PadApiInterface {
    /**
     * 
     * @summary appends a chat message
     * @param {string} [padID] 
     * @param {string} [text] 
     * @param {string} [authorID] 
     * @param {string} [time] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    appendChatMessageUsingGET(padID?: string, text?: string, authorID?: string, time?: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteGroupUsingGET200Response>;

    /**
     * 
     * @summary appends a chat message
     * @param {string} [padID] 
     * @param {string} [text] 
     * @param {string} [authorID] 
     * @param {string} [time] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    appendChatMessageUsingPOST(padID?: string, text?: string, authorID?: string, time?: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteGroupUsingGET200Response>;

    /**
     * 
     * @summary returns ok when the current api token is valid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    checkTokenUsingGET(options?: RawAxiosRequestConfig): AxiosPromise<DeleteGroupUsingGET200Response>;

    /**
     * 
     * @summary returns ok when the current api token is valid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    checkTokenUsingPOST(options?: RawAxiosRequestConfig): AxiosPromise<DeleteGroupUsingGET200Response>;

    /**
     * 
     * @summary 
     * @param {string} [padID] 
     * @param {string} [startRev] 
     * @param {string} [endRev] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    createDiffHTMLUsingGET(padID?: string, startRev?: string, endRev?: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateDiffHTMLUsingGET200Response>;

    /**
     * 
     * @summary 
     * @param {string} [padID] 
     * @param {string} [startRev] 
     * @param {string} [endRev] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    createDiffHTMLUsingPOST(padID?: string, startRev?: string, endRev?: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateDiffHTMLUsingGET200Response>;

    /**
     * creates a new (non-group) pad. Note that if you need to create a group Pad, you should call createGroupPad
     * @param {string} [padID] 
     * @param {string} [text] 
     * @param {string} [authorId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    createPadUsingGET(padID?: string, text?: string, authorId?: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteGroupUsingGET200Response>;

    /**
     * creates a new (non-group) pad. Note that if you need to create a group Pad, you should call createGroupPad
     * @param {string} [padID] 
     * @param {string} [text] 
     * @param {string} [authorId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    createPadUsingPOST(padID?: string, text?: string, authorId?: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteGroupUsingGET200Response>;

    /**
     * 
     * @summary deletes a pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    deletePadUsingGET(padID?: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteGroupUsingGET200Response>;

    /**
     * 
     * @summary deletes a pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    deletePadUsingPOST(padID?: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteGroupUsingGET200Response>;

    /**
     * 
     * @summary returns the chatHead (chat-message) of the pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    getChatHeadUsingGET(padID?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetChatHeadUsingGET200Response>;

    /**
     * 
     * @summary returns the chatHead (chat-message) of the pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    getChatHeadUsingPOST(padID?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetChatHeadUsingGET200Response>;

    /**
     * 
     * @summary returns the chat history
     * @param {string} [padID] 
     * @param {string} [start] 
     * @param {string} [end] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    getChatHistoryUsingGET(padID?: string, start?: string, end?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetChatHistoryUsingGET200Response>;

    /**
     * 
     * @summary returns the chat history
     * @param {string} [padID] 
     * @param {string} [start] 
     * @param {string} [end] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    getChatHistoryUsingPOST(padID?: string, start?: string, end?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetChatHistoryUsingGET200Response>;

    /**
     * 
     * @summary returns the text of a pad formatted as HTML
     * @param {string} [padID] 
     * @param {string} [rev] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    getHTMLUsingGET(padID?: string, rev?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetHTMLUsingGET200Response>;

    /**
     * 
     * @summary returns the text of a pad formatted as HTML
     * @param {string} [padID] 
     * @param {string} [rev] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    getHTMLUsingPOST(padID?: string, rev?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetHTMLUsingGET200Response>;

    /**
     * 
     * @summary returns the timestamp of the last revision of the pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    getLastEditedUsingGET(padID?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetLastEditedUsingGET200Response>;

    /**
     * 
     * @summary returns the timestamp of the last revision of the pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    getLastEditedUsingPOST(padID?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetLastEditedUsingGET200Response>;

    /**
     * 
     * @summary return true of false
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    getPublicStatusUsingGET(padID?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetPublicStatusUsingGET200Response>;

    /**
     * 
     * @summary return true of false
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    getPublicStatusUsingPOST(padID?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetPublicStatusUsingGET200Response>;

    /**
     * 
     * @summary returns the read only link of a pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    getReadOnlyIDUsingGET(padID?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetReadOnlyIDUsingGET200Response>;

    /**
     * 
     * @summary returns the read only link of a pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    getReadOnlyIDUsingPOST(padID?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetReadOnlyIDUsingGET200Response>;

    /**
     * 
     * @summary returns the number of revisions of this pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    getRevisionsCountUsingGET(padID?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRevisionsCountUsingGET200Response>;

    /**
     * 
     * @summary returns the number of revisions of this pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    getRevisionsCountUsingPOST(padID?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRevisionsCountUsingGET200Response>;

    /**
     * 
     * @summary returns the text of a pad
     * @param {string} [padID] 
     * @param {string} [rev] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    getTextUsingGET(padID?: string, rev?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetTextUsingGET200Response>;

    /**
     * 
     * @summary returns the text of a pad
     * @param {string} [padID] 
     * @param {string} [rev] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    getTextUsingPOST(padID?: string, rev?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetTextUsingGET200Response>;

    /**
     * 
     * @summary list all the pads
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    listAllPadsUsingGET(options?: RawAxiosRequestConfig): AxiosPromise<ListPadsUsingGET200Response>;

    /**
     * 
     * @summary list all the pads
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    listAllPadsUsingPOST(options?: RawAxiosRequestConfig): AxiosPromise<ListPadsUsingGET200Response>;

    /**
     * 
     * @summary returns an array of authors who contributed to this pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    listAuthorsOfPadUsingGET(padID?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListAuthorsOfPadUsingGET200Response>;

    /**
     * 
     * @summary returns an array of authors who contributed to this pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    listAuthorsOfPadUsingPOST(padID?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListAuthorsOfPadUsingGET200Response>;

    /**
     * 
     * @summary returns the number of user that are currently editing this pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    padUsersCountUsingGET(padID?: string, options?: RawAxiosRequestConfig): AxiosPromise<PadUsersCountUsingGET200Response>;

    /**
     * 
     * @summary returns the number of user that are currently editing this pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    padUsersCountUsingPOST(padID?: string, options?: RawAxiosRequestConfig): AxiosPromise<PadUsersCountUsingGET200Response>;

    /**
     * 
     * @summary returns the list of users that are currently editing this pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    padUsersUsingGET(padID?: string, options?: RawAxiosRequestConfig): AxiosPromise<PadUsersUsingGET200Response>;

    /**
     * 
     * @summary returns the list of users that are currently editing this pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    padUsersUsingPOST(padID?: string, options?: RawAxiosRequestConfig): AxiosPromise<PadUsersUsingGET200Response>;

    /**
     * 
     * @summary sends a custom message of type msg to the pad
     * @param {string} [padID] 
     * @param {string} [msg] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    sendClientsMessageUsingGET(padID?: string, msg?: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteGroupUsingGET200Response>;

    /**
     * 
     * @summary sends a custom message of type msg to the pad
     * @param {string} [padID] 
     * @param {string} [msg] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    sendClientsMessageUsingPOST(padID?: string, msg?: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteGroupUsingGET200Response>;

    /**
     * 
     * @summary sets the text of a pad with HTML
     * @param {string} [padID] 
     * @param {string} [html] 
     * @param {string} [authorId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    setHTMLUsingGET(padID?: string, html?: string, authorId?: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteGroupUsingGET200Response>;

    /**
     * 
     * @summary sets the text of a pad with HTML
     * @param {string} [padID] 
     * @param {string} [html] 
     * @param {string} [authorId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    setHTMLUsingPOST(padID?: string, html?: string, authorId?: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteGroupUsingGET200Response>;

    /**
     * 
     * @summary sets a boolean for the public status of a pad
     * @param {string} [padID] 
     * @param {string} [publicStatus] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    setPublicStatusUsingGET(padID?: string, publicStatus?: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteGroupUsingGET200Response>;

    /**
     * 
     * @summary sets a boolean for the public status of a pad
     * @param {string} [padID] 
     * @param {string} [publicStatus] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    setPublicStatusUsingPOST(padID?: string, publicStatus?: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteGroupUsingGET200Response>;

    /**
     * 
     * @summary sets the text of a pad
     * @param {string} [padID] 
     * @param {string} [text] 
     * @param {string} [authorId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    setTextUsingGET(padID?: string, text?: string, authorId?: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteGroupUsingGET200Response>;

    /**
     * 
     * @summary sets the text of a pad
     * @param {string} [padID] 
     * @param {string} [text] 
     * @param {string} [authorId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApiInterface
     */
    setTextUsingPOST(padID?: string, text?: string, authorId?: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteGroupUsingGET200Response>;

}

/**
 * PadApi - object-oriented interface
 * @export
 * @class PadApi
 * @extends {BaseAPI}
 */
export class PadApi extends BaseAPI implements PadApiInterface {
    /**
     * 
     * @summary appends a chat message
     * @param {string} [padID] 
     * @param {string} [text] 
     * @param {string} [authorID] 
     * @param {string} [time] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public appendChatMessageUsingGET(padID?: string, text?: string, authorID?: string, time?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).appendChatMessageUsingGET(padID, text, authorID, time, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary appends a chat message
     * @param {string} [padID] 
     * @param {string} [text] 
     * @param {string} [authorID] 
     * @param {string} [time] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public appendChatMessageUsingPOST(padID?: string, text?: string, authorID?: string, time?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).appendChatMessageUsingPOST(padID, text, authorID, time, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns ok when the current api token is valid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public checkTokenUsingGET(options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).checkTokenUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns ok when the current api token is valid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public checkTokenUsingPOST(options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).checkTokenUsingPOST(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} [padID] 
     * @param {string} [startRev] 
     * @param {string} [endRev] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public createDiffHTMLUsingGET(padID?: string, startRev?: string, endRev?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).createDiffHTMLUsingGET(padID, startRev, endRev, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} [padID] 
     * @param {string} [startRev] 
     * @param {string} [endRev] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public createDiffHTMLUsingPOST(padID?: string, startRev?: string, endRev?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).createDiffHTMLUsingPOST(padID, startRev, endRev, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * creates a new (non-group) pad. Note that if you need to create a group Pad, you should call createGroupPad
     * @param {string} [padID] 
     * @param {string} [text] 
     * @param {string} [authorId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public createPadUsingGET(padID?: string, text?: string, authorId?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).createPadUsingGET(padID, text, authorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * creates a new (non-group) pad. Note that if you need to create a group Pad, you should call createGroupPad
     * @param {string} [padID] 
     * @param {string} [text] 
     * @param {string} [authorId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public createPadUsingPOST(padID?: string, text?: string, authorId?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).createPadUsingPOST(padID, text, authorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deletes a pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public deletePadUsingGET(padID?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).deletePadUsingGET(padID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deletes a pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public deletePadUsingPOST(padID?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).deletePadUsingPOST(padID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the chatHead (chat-message) of the pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public getChatHeadUsingGET(padID?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).getChatHeadUsingGET(padID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the chatHead (chat-message) of the pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public getChatHeadUsingPOST(padID?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).getChatHeadUsingPOST(padID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the chat history
     * @param {string} [padID] 
     * @param {string} [start] 
     * @param {string} [end] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public getChatHistoryUsingGET(padID?: string, start?: string, end?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).getChatHistoryUsingGET(padID, start, end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the chat history
     * @param {string} [padID] 
     * @param {string} [start] 
     * @param {string} [end] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public getChatHistoryUsingPOST(padID?: string, start?: string, end?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).getChatHistoryUsingPOST(padID, start, end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the text of a pad formatted as HTML
     * @param {string} [padID] 
     * @param {string} [rev] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public getHTMLUsingGET(padID?: string, rev?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).getHTMLUsingGET(padID, rev, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the text of a pad formatted as HTML
     * @param {string} [padID] 
     * @param {string} [rev] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public getHTMLUsingPOST(padID?: string, rev?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).getHTMLUsingPOST(padID, rev, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the timestamp of the last revision of the pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public getLastEditedUsingGET(padID?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).getLastEditedUsingGET(padID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the timestamp of the last revision of the pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public getLastEditedUsingPOST(padID?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).getLastEditedUsingPOST(padID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary return true of false
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public getPublicStatusUsingGET(padID?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).getPublicStatusUsingGET(padID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary return true of false
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public getPublicStatusUsingPOST(padID?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).getPublicStatusUsingPOST(padID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the read only link of a pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public getReadOnlyIDUsingGET(padID?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).getReadOnlyIDUsingGET(padID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the read only link of a pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public getReadOnlyIDUsingPOST(padID?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).getReadOnlyIDUsingPOST(padID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the number of revisions of this pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public getRevisionsCountUsingGET(padID?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).getRevisionsCountUsingGET(padID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the number of revisions of this pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public getRevisionsCountUsingPOST(padID?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).getRevisionsCountUsingPOST(padID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the text of a pad
     * @param {string} [padID] 
     * @param {string} [rev] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public getTextUsingGET(padID?: string, rev?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).getTextUsingGET(padID, rev, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the text of a pad
     * @param {string} [padID] 
     * @param {string} [rev] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public getTextUsingPOST(padID?: string, rev?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).getTextUsingPOST(padID, rev, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary list all the pads
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public listAllPadsUsingGET(options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).listAllPadsUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary list all the pads
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public listAllPadsUsingPOST(options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).listAllPadsUsingPOST(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns an array of authors who contributed to this pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public listAuthorsOfPadUsingGET(padID?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).listAuthorsOfPadUsingGET(padID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns an array of authors who contributed to this pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public listAuthorsOfPadUsingPOST(padID?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).listAuthorsOfPadUsingPOST(padID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the number of user that are currently editing this pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public padUsersCountUsingGET(padID?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).padUsersCountUsingGET(padID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the number of user that are currently editing this pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public padUsersCountUsingPOST(padID?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).padUsersCountUsingPOST(padID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the list of users that are currently editing this pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public padUsersUsingGET(padID?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).padUsersUsingGET(padID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the list of users that are currently editing this pad
     * @param {string} [padID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public padUsersUsingPOST(padID?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).padUsersUsingPOST(padID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary sends a custom message of type msg to the pad
     * @param {string} [padID] 
     * @param {string} [msg] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public sendClientsMessageUsingGET(padID?: string, msg?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).sendClientsMessageUsingGET(padID, msg, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary sends a custom message of type msg to the pad
     * @param {string} [padID] 
     * @param {string} [msg] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public sendClientsMessageUsingPOST(padID?: string, msg?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).sendClientsMessageUsingPOST(padID, msg, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary sets the text of a pad with HTML
     * @param {string} [padID] 
     * @param {string} [html] 
     * @param {string} [authorId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public setHTMLUsingGET(padID?: string, html?: string, authorId?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).setHTMLUsingGET(padID, html, authorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary sets the text of a pad with HTML
     * @param {string} [padID] 
     * @param {string} [html] 
     * @param {string} [authorId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public setHTMLUsingPOST(padID?: string, html?: string, authorId?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).setHTMLUsingPOST(padID, html, authorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary sets a boolean for the public status of a pad
     * @param {string} [padID] 
     * @param {string} [publicStatus] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public setPublicStatusUsingGET(padID?: string, publicStatus?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).setPublicStatusUsingGET(padID, publicStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary sets a boolean for the public status of a pad
     * @param {string} [padID] 
     * @param {string} [publicStatus] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public setPublicStatusUsingPOST(padID?: string, publicStatus?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).setPublicStatusUsingPOST(padID, publicStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary sets the text of a pad
     * @param {string} [padID] 
     * @param {string} [text] 
     * @param {string} [authorId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public setTextUsingGET(padID?: string, text?: string, authorId?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).setTextUsingGET(padID, text, authorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary sets the text of a pad
     * @param {string} [padID] 
     * @param {string} [text] 
     * @param {string} [authorId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PadApi
     */
    public setTextUsingPOST(padID?: string, text?: string, authorId?: string, options?: RawAxiosRequestConfig) {
        return PadApiFp(this.configuration).setTextUsingPOST(padID, text, authorId, options).then((request) => request(this.axios, this.basePath));
    }
}

