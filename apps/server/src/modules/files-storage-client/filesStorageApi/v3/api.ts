/* tslint:disable */
/* eslint-disable */
/**
 * HPI Schul-Cloud Server API
 * This is v3 of HPI Schul-Cloud Server. Checkout /docs for v1.
 *
 * The version of the OpenAPI document: 3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ApiValidationError
 */
export interface ApiValidationError {
    /**
     * The response status code.
     * @type {number}
     * @memberof ApiValidationError
     */
    'code': number;
    /**
     * The error type.
     * @type {string}
     * @memberof ApiValidationError
     */
    'type': string;
    /**
     * The error title.
     * @type {string}
     * @memberof ApiValidationError
     */
    'title': string;
    /**
     * The error message.
     * @type {string}
     * @memberof ApiValidationError
     */
    'message': string;
    /**
     * The error details.
     * @type {object}
     * @memberof ApiValidationError
     */
    'details': object;
}
/**
 * 
 * @export
 * @interface CopyFileListResponse
 */
export interface CopyFileListResponse {
    /**
     * The items for the current page.
     * @type {Array<CopyFileResponse>}
     * @memberof CopyFileListResponse
     */
    'data': Array<CopyFileResponse>;
    /**
     * The total amount of items.
     * @type {number}
     * @memberof CopyFileListResponse
     */
    'total': number;
    /**
     * The amount of items skipped from the start.
     * @type {number}
     * @memberof CopyFileListResponse
     */
    'skip': number;
    /**
     * The page size of the response.
     * @type {number}
     * @memberof CopyFileListResponse
     */
    'limit': number;
}
/**
 * 
 * @export
 * @interface CopyFileParams
 */
export interface CopyFileParams {
    /**
     * 
     * @type {FileRecordParams}
     * @memberof CopyFileParams
     */
    'target': FileRecordParams;
    /**
     * 
     * @type {string}
     * @memberof CopyFileParams
     */
    'fileNamePrefix': string;
}
/**
 * 
 * @export
 * @interface CopyFileResponse
 */
export interface CopyFileResponse {
    /**
     * 
     * @type {string}
     * @memberof CopyFileResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CopyFileResponse
     */
    'sourceId': string;
    /**
     * 
     * @type {string}
     * @memberof CopyFileResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CopyFilesOfParentParams
 */
export interface CopyFilesOfParentParams {
    /**
     * 
     * @type {FileRecordParams}
     * @memberof CopyFilesOfParentParams
     */
    'target': FileRecordParams;
}
/**
 * 
 * @export
 * @interface FileRecordListResponse
 */
export interface FileRecordListResponse {
    /**
     * The items for the current page.
     * @type {Array<FileRecordResponse>}
     * @memberof FileRecordListResponse
     */
    'data': Array<FileRecordResponse>;
    /**
     * The total amount of items.
     * @type {number}
     * @memberof FileRecordListResponse
     */
    'total': number;
    /**
     * The amount of items skipped from the start.
     * @type {number}
     * @memberof FileRecordListResponse
     */
    'skip': number;
    /**
     * The page size of the response.
     * @type {number}
     * @memberof FileRecordListResponse
     */
    'limit': number;
}
/**
 * 
 * @export
 * @interface FileRecordParams
 */
export interface FileRecordParams {
    /**
     * 
     * @type {string}
     * @memberof FileRecordParams
     */
    'schoolId': string;
    /**
     * 
     * @type {string}
     * @memberof FileRecordParams
     */
    'parentId': string;
    /**
     * 
     * @type {string}
     * @memberof FileRecordParams
     */
    'parentType': FileRecordParamsParentTypeEnum;
}

export const FileRecordParamsParentTypeEnum = {
    Users: 'users',
    Schools: 'schools',
    Courses: 'courses',
    Tasks: 'tasks',
    Lessons: 'lessons'
} as const;

export type FileRecordParamsParentTypeEnum = typeof FileRecordParamsParentTypeEnum[keyof typeof FileRecordParamsParentTypeEnum];

/**
 * 
 * @export
 * @interface FileRecordResponse
 */
export interface FileRecordResponse {
    /**
     * 
     * @type {string}
     * @memberof FileRecordResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FileRecordResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FileRecordResponse
     */
    'parentId': string;
    /**
     * 
     * @type {string}
     * @memberof FileRecordResponse
     */
    'securityCheckStatus': string;
    /**
     * 
     * @type {number}
     * @memberof FileRecordResponse
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof FileRecordResponse
     */
    'creatorId': string;
    /**
     * 
     * @type {string}
     * @memberof FileRecordResponse
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof FileRecordResponse
     */
    'parentType': string;
    /**
     * 
     * @type {string}
     * @memberof FileRecordResponse
     */
    'deletedSince'?: string;
}
/**
 * 
 * @export
 * @interface RenameFileParams
 */
export interface RenameFileParams {
    /**
     * 
     * @type {string}
     * @memberof RenameFileParams
     */
    'fileName': string;
}

/**
 * FileApi - axios parameter creator
 * @export
 */
export const FileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Copy all files of a parent entityId to a target entitId
         * @param {string} schoolId 
         * @param {string} parentId 
         * @param {'users' | 'schools' | 'courses' | 'tasks' | 'lessons'} parentType 
         * @param {CopyFilesOfParentParams} copyFilesOfParentParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesStorageControllerCopy: async (schoolId: string, parentId: string, parentType: 'users' | 'schools' | 'courses' | 'tasks' | 'lessons', copyFilesOfParentParams: CopyFilesOfParentParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('filesStorageControllerCopy', 'schoolId', schoolId)
            // verify required parameter 'parentId' is not null or undefined
            assertParamExists('filesStorageControllerCopy', 'parentId', parentId)
            // verify required parameter 'parentType' is not null or undefined
            assertParamExists('filesStorageControllerCopy', 'parentType', parentType)
            // verify required parameter 'copyFilesOfParentParams' is not null or undefined
            assertParamExists('filesStorageControllerCopy', 'copyFilesOfParentParams', copyFilesOfParentParams)
            const localVarPath = `/file/copy/{schoolId}/{parentType}/{parentId}`
                .replace(`{${"schoolId"}}`, encodeURIComponent(String(schoolId)))
                .replace(`{${"parentId"}}`, encodeURIComponent(String(parentId)))
                .replace(`{${"parentType"}}`, encodeURIComponent(String(parentType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(copyFilesOfParentParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Copy a single file in the same target entityId scope.
         * @param {string} fileRecordId 
         * @param {CopyFileParams} copyFileParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesStorageControllerCopyFile: async (fileRecordId: string, copyFileParams: CopyFileParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileRecordId' is not null or undefined
            assertParamExists('filesStorageControllerCopyFile', 'fileRecordId', fileRecordId)
            // verify required parameter 'copyFileParams' is not null or undefined
            assertParamExists('filesStorageControllerCopyFile', 'copyFileParams', copyFileParams)
            const localVarPath = `/file/copy/{fileRecordId}`
                .replace(`{${"fileRecordId"}}`, encodeURIComponent(String(fileRecordId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(copyFileParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark all files of a parent entityId for deletion. The files are permanently deleted after a certain time.
         * @param {string} schoolId 
         * @param {string} parentId 
         * @param {'users' | 'schools' | 'courses' | 'tasks' | 'lessons'} parentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesStorageControllerDelete: async (schoolId: string, parentId: string, parentType: 'users' | 'schools' | 'courses' | 'tasks' | 'lessons', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('filesStorageControllerDelete', 'schoolId', schoolId)
            // verify required parameter 'parentId' is not null or undefined
            assertParamExists('filesStorageControllerDelete', 'parentId', parentId)
            // verify required parameter 'parentType' is not null or undefined
            assertParamExists('filesStorageControllerDelete', 'parentType', parentType)
            const localVarPath = `/file/delete/{schoolId}/{parentType}/{parentId}`
                .replace(`{${"schoolId"}}`, encodeURIComponent(String(schoolId)))
                .replace(`{${"parentId"}}`, encodeURIComponent(String(parentId)))
                .replace(`{${"parentType"}}`, encodeURIComponent(String(parentType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark a single file for deletion. The files are permanently deleted after a certain time.
         * @param {string} fileRecordId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesStorageControllerDeleteFile: async (fileRecordId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileRecordId' is not null or undefined
            assertParamExists('filesStorageControllerDeleteFile', 'fileRecordId', fileRecordId)
            const localVarPath = `/file/delete/{fileRecordId}`
                .replace(`{${"fileRecordId"}}`, encodeURIComponent(String(fileRecordId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Streamable download of a binary file.
         * @param {string} fileRecordId 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesStorageControllerDownload: async (fileRecordId: string, fileName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileRecordId' is not null or undefined
            assertParamExists('filesStorageControllerDownload', 'fileRecordId', fileRecordId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('filesStorageControllerDownload', 'fileName', fileName)
            const localVarPath = `/file/download/{fileRecordId}/{fileName}`
                .replace(`{${"fileRecordId"}}`, encodeURIComponent(String(fileRecordId)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of file meta data of a parent entityId.
         * @param {string} schoolId 
         * @param {string} parentId 
         * @param {'users' | 'schools' | 'courses' | 'tasks' | 'lessons'} parentType 
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesStorageControllerList: async (schoolId: string, parentId: string, parentType: 'users' | 'schools' | 'courses' | 'tasks' | 'lessons', skip?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('filesStorageControllerList', 'schoolId', schoolId)
            // verify required parameter 'parentId' is not null or undefined
            assertParamExists('filesStorageControllerList', 'parentId', parentId)
            // verify required parameter 'parentType' is not null or undefined
            assertParamExists('filesStorageControllerList', 'parentType', parentType)
            const localVarPath = `/file/list/{schoolId}/{parentType}/{parentId}`
                .replace(`{${"schoolId"}}`, encodeURIComponent(String(schoolId)))
                .replace(`{${"parentId"}}`, encodeURIComponent(String(parentId)))
                .replace(`{${"parentType"}}`, encodeURIComponent(String(parentType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rename a single file.
         * @param {string} fileRecordId 
         * @param {RenameFileParams} renameFileParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesStorageControllerPatchFilename: async (fileRecordId: string, renameFileParams: RenameFileParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileRecordId' is not null or undefined
            assertParamExists('filesStorageControllerPatchFilename', 'fileRecordId', fileRecordId)
            // verify required parameter 'renameFileParams' is not null or undefined
            assertParamExists('filesStorageControllerPatchFilename', 'renameFileParams', renameFileParams)
            const localVarPath = `/file/rename/{fileRecordId}`
                .replace(`{${"fileRecordId"}}`, encodeURIComponent(String(fileRecordId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(renameFileParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore all files of a parent entityId that are marked for deletion.
         * @param {string} schoolId 
         * @param {string} parentId 
         * @param {'users' | 'schools' | 'courses' | 'tasks' | 'lessons'} parentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesStorageControllerRestore: async (schoolId: string, parentId: string, parentType: 'users' | 'schools' | 'courses' | 'tasks' | 'lessons', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('filesStorageControllerRestore', 'schoolId', schoolId)
            // verify required parameter 'parentId' is not null or undefined
            assertParamExists('filesStorageControllerRestore', 'parentId', parentId)
            // verify required parameter 'parentType' is not null or undefined
            assertParamExists('filesStorageControllerRestore', 'parentType', parentType)
            const localVarPath = `/file/restore/{schoolId}/{parentType}/{parentId}`
                .replace(`{${"schoolId"}}`, encodeURIComponent(String(schoolId)))
                .replace(`{${"parentId"}}`, encodeURIComponent(String(parentId)))
                .replace(`{${"parentType"}}`, encodeURIComponent(String(parentType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a single file that is marked for deletion.
         * @param {string} fileRecordId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesStorageControllerRestoreFile: async (fileRecordId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileRecordId' is not null or undefined
            assertParamExists('filesStorageControllerRestoreFile', 'fileRecordId', fileRecordId)
            const localVarPath = `/file/restore/{fileRecordId}`
                .replace(`{${"fileRecordId"}}`, encodeURIComponent(String(fileRecordId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Streamable upload of a binary file.
         * @param {string} schoolId 
         * @param {string} parentId 
         * @param {'users' | 'schools' | 'courses' | 'tasks' | 'lessons'} parentType 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesStorageControllerUpload: async (schoolId: string, parentId: string, parentType: 'users' | 'schools' | 'courses' | 'tasks' | 'lessons', file: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('filesStorageControllerUpload', 'schoolId', schoolId)
            // verify required parameter 'parentId' is not null or undefined
            assertParamExists('filesStorageControllerUpload', 'parentId', parentId)
            // verify required parameter 'parentType' is not null or undefined
            assertParamExists('filesStorageControllerUpload', 'parentType', parentType)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('filesStorageControllerUpload', 'file', file)
            const localVarPath = `/file/upload/{schoolId}/{parentType}/{parentId}`
                .replace(`{${"schoolId"}}`, encodeURIComponent(String(schoolId)))
                .replace(`{${"parentId"}}`, encodeURIComponent(String(parentId)))
                .replace(`{${"parentType"}}`, encodeURIComponent(String(parentType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileApi - functional programming interface
 * @export
 */
export const FileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Copy all files of a parent entityId to a target entitId
         * @param {string} schoolId 
         * @param {string} parentId 
         * @param {'users' | 'schools' | 'courses' | 'tasks' | 'lessons'} parentType 
         * @param {CopyFilesOfParentParams} copyFilesOfParentParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesStorageControllerCopy(schoolId: string, parentId: string, parentType: 'users' | 'schools' | 'courses' | 'tasks' | 'lessons', copyFilesOfParentParams: CopyFilesOfParentParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CopyFileListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesStorageControllerCopy(schoolId, parentId, parentType, copyFilesOfParentParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Copy a single file in the same target entityId scope.
         * @param {string} fileRecordId 
         * @param {CopyFileParams} copyFileParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesStorageControllerCopyFile(fileRecordId: string, copyFileParams: CopyFileParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileRecordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesStorageControllerCopyFile(fileRecordId, copyFileParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Mark all files of a parent entityId for deletion. The files are permanently deleted after a certain time.
         * @param {string} schoolId 
         * @param {string} parentId 
         * @param {'users' | 'schools' | 'courses' | 'tasks' | 'lessons'} parentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesStorageControllerDelete(schoolId: string, parentId: string, parentType: 'users' | 'schools' | 'courses' | 'tasks' | 'lessons', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileRecordListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesStorageControllerDelete(schoolId, parentId, parentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Mark a single file for deletion. The files are permanently deleted after a certain time.
         * @param {string} fileRecordId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesStorageControllerDeleteFile(fileRecordId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileRecordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesStorageControllerDeleteFile(fileRecordId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Streamable download of a binary file.
         * @param {string} fileRecordId 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesStorageControllerDownload(fileRecordId: string, fileName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesStorageControllerDownload(fileRecordId, fileName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of file meta data of a parent entityId.
         * @param {string} schoolId 
         * @param {string} parentId 
         * @param {'users' | 'schools' | 'courses' | 'tasks' | 'lessons'} parentType 
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesStorageControllerList(schoolId: string, parentId: string, parentType: 'users' | 'schools' | 'courses' | 'tasks' | 'lessons', skip?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileRecordListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesStorageControllerList(schoolId, parentId, parentType, skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Rename a single file.
         * @param {string} fileRecordId 
         * @param {RenameFileParams} renameFileParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesStorageControllerPatchFilename(fileRecordId: string, renameFileParams: RenameFileParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileRecordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesStorageControllerPatchFilename(fileRecordId, renameFileParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Restore all files of a parent entityId that are marked for deletion.
         * @param {string} schoolId 
         * @param {string} parentId 
         * @param {'users' | 'schools' | 'courses' | 'tasks' | 'lessons'} parentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesStorageControllerRestore(schoolId: string, parentId: string, parentType: 'users' | 'schools' | 'courses' | 'tasks' | 'lessons', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileRecordListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesStorageControllerRestore(schoolId, parentId, parentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Restore a single file that is marked for deletion.
         * @param {string} fileRecordId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesStorageControllerRestoreFile(fileRecordId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileRecordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesStorageControllerRestoreFile(fileRecordId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Streamable upload of a binary file.
         * @param {string} schoolId 
         * @param {string} parentId 
         * @param {'users' | 'schools' | 'courses' | 'tasks' | 'lessons'} parentType 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesStorageControllerUpload(schoolId: string, parentId: string, parentType: 'users' | 'schools' | 'courses' | 'tasks' | 'lessons', file: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileRecordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesStorageControllerUpload(schoolId, parentId, parentType, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FileApi - factory interface
 * @export
 */
export const FileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileApiFp(configuration)
    return {
        /**
         * 
         * @summary Copy all files of a parent entityId to a target entitId
         * @param {string} schoolId 
         * @param {string} parentId 
         * @param {'users' | 'schools' | 'courses' | 'tasks' | 'lessons'} parentType 
         * @param {CopyFilesOfParentParams} copyFilesOfParentParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesStorageControllerCopy(schoolId: string, parentId: string, parentType: 'users' | 'schools' | 'courses' | 'tasks' | 'lessons', copyFilesOfParentParams: CopyFilesOfParentParams, options?: any): AxiosPromise<CopyFileListResponse> {
            return localVarFp.filesStorageControllerCopy(schoolId, parentId, parentType, copyFilesOfParentParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Copy a single file in the same target entityId scope.
         * @param {string} fileRecordId 
         * @param {CopyFileParams} copyFileParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesStorageControllerCopyFile(fileRecordId: string, copyFileParams: CopyFileParams, options?: any): AxiosPromise<FileRecordResponse> {
            return localVarFp.filesStorageControllerCopyFile(fileRecordId, copyFileParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark all files of a parent entityId for deletion. The files are permanently deleted after a certain time.
         * @param {string} schoolId 
         * @param {string} parentId 
         * @param {'users' | 'schools' | 'courses' | 'tasks' | 'lessons'} parentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesStorageControllerDelete(schoolId: string, parentId: string, parentType: 'users' | 'schools' | 'courses' | 'tasks' | 'lessons', options?: any): AxiosPromise<FileRecordListResponse> {
            return localVarFp.filesStorageControllerDelete(schoolId, parentId, parentType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark a single file for deletion. The files are permanently deleted after a certain time.
         * @param {string} fileRecordId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesStorageControllerDeleteFile(fileRecordId: string, options?: any): AxiosPromise<FileRecordResponse> {
            return localVarFp.filesStorageControllerDeleteFile(fileRecordId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Streamable download of a binary file.
         * @param {string} fileRecordId 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesStorageControllerDownload(fileRecordId: string, fileName: string, options?: any): AxiosPromise<object> {
            return localVarFp.filesStorageControllerDownload(fileRecordId, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of file meta data of a parent entityId.
         * @param {string} schoolId 
         * @param {string} parentId 
         * @param {'users' | 'schools' | 'courses' | 'tasks' | 'lessons'} parentType 
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesStorageControllerList(schoolId: string, parentId: string, parentType: 'users' | 'schools' | 'courses' | 'tasks' | 'lessons', skip?: number, limit?: number, options?: any): AxiosPromise<FileRecordListResponse> {
            return localVarFp.filesStorageControllerList(schoolId, parentId, parentType, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rename a single file.
         * @param {string} fileRecordId 
         * @param {RenameFileParams} renameFileParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesStorageControllerPatchFilename(fileRecordId: string, renameFileParams: RenameFileParams, options?: any): AxiosPromise<FileRecordResponse> {
            return localVarFp.filesStorageControllerPatchFilename(fileRecordId, renameFileParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore all files of a parent entityId that are marked for deletion.
         * @param {string} schoolId 
         * @param {string} parentId 
         * @param {'users' | 'schools' | 'courses' | 'tasks' | 'lessons'} parentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesStorageControllerRestore(schoolId: string, parentId: string, parentType: 'users' | 'schools' | 'courses' | 'tasks' | 'lessons', options?: any): AxiosPromise<FileRecordListResponse> {
            return localVarFp.filesStorageControllerRestore(schoolId, parentId, parentType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a single file that is marked for deletion.
         * @param {string} fileRecordId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesStorageControllerRestoreFile(fileRecordId: string, options?: any): AxiosPromise<FileRecordResponse> {
            return localVarFp.filesStorageControllerRestoreFile(fileRecordId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Streamable upload of a binary file.
         * @param {string} schoolId 
         * @param {string} parentId 
         * @param {'users' | 'schools' | 'courses' | 'tasks' | 'lessons'} parentType 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesStorageControllerUpload(schoolId: string, parentId: string, parentType: 'users' | 'schools' | 'courses' | 'tasks' | 'lessons', file: any, options?: any): AxiosPromise<FileRecordResponse> {
            return localVarFp.filesStorageControllerUpload(schoolId, parentId, parentType, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileApi - interface
 * @export
 * @interface FileApi
 */
export interface FileApiInterface {
    /**
     * 
     * @summary Copy all files of a parent entityId to a target entitId
     * @param {string} schoolId 
     * @param {string} parentId 
     * @param {'users' | 'schools' | 'courses' | 'tasks' | 'lessons'} parentType 
     * @param {CopyFilesOfParentParams} copyFilesOfParentParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApiInterface
     */
    filesStorageControllerCopy(schoolId: string, parentId: string, parentType: 'users' | 'schools' | 'courses' | 'tasks' | 'lessons', copyFilesOfParentParams: CopyFilesOfParentParams, options?: AxiosRequestConfig): AxiosPromise<CopyFileListResponse>;

    /**
     * 
     * @summary Copy a single file in the same target entityId scope.
     * @param {string} fileRecordId 
     * @param {CopyFileParams} copyFileParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApiInterface
     */
    filesStorageControllerCopyFile(fileRecordId: string, copyFileParams: CopyFileParams, options?: AxiosRequestConfig): AxiosPromise<FileRecordResponse>;

    /**
     * 
     * @summary Mark all files of a parent entityId for deletion. The files are permanently deleted after a certain time.
     * @param {string} schoolId 
     * @param {string} parentId 
     * @param {'users' | 'schools' | 'courses' | 'tasks' | 'lessons'} parentType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApiInterface
     */
    filesStorageControllerDelete(schoolId: string, parentId: string, parentType: 'users' | 'schools' | 'courses' | 'tasks' | 'lessons', options?: AxiosRequestConfig): AxiosPromise<FileRecordListResponse>;

    /**
     * 
     * @summary Mark a single file for deletion. The files are permanently deleted after a certain time.
     * @param {string} fileRecordId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApiInterface
     */
    filesStorageControllerDeleteFile(fileRecordId: string, options?: AxiosRequestConfig): AxiosPromise<FileRecordResponse>;

    /**
     * 
     * @summary Streamable download of a binary file.
     * @param {string} fileRecordId 
     * @param {string} fileName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApiInterface
     */
    filesStorageControllerDownload(fileRecordId: string, fileName: string, options?: AxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get a list of file meta data of a parent entityId.
     * @param {string} schoolId 
     * @param {string} parentId 
     * @param {'users' | 'schools' | 'courses' | 'tasks' | 'lessons'} parentType 
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApiInterface
     */
    filesStorageControllerList(schoolId: string, parentId: string, parentType: 'users' | 'schools' | 'courses' | 'tasks' | 'lessons', skip?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<FileRecordListResponse>;

    /**
     * 
     * @summary Rename a single file.
     * @param {string} fileRecordId 
     * @param {RenameFileParams} renameFileParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApiInterface
     */
    filesStorageControllerPatchFilename(fileRecordId: string, renameFileParams: RenameFileParams, options?: AxiosRequestConfig): AxiosPromise<FileRecordResponse>;

    /**
     * 
     * @summary Restore all files of a parent entityId that are marked for deletion.
     * @param {string} schoolId 
     * @param {string} parentId 
     * @param {'users' | 'schools' | 'courses' | 'tasks' | 'lessons'} parentType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApiInterface
     */
    filesStorageControllerRestore(schoolId: string, parentId: string, parentType: 'users' | 'schools' | 'courses' | 'tasks' | 'lessons', options?: AxiosRequestConfig): AxiosPromise<FileRecordListResponse>;

    /**
     * 
     * @summary Restore a single file that is marked for deletion.
     * @param {string} fileRecordId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApiInterface
     */
    filesStorageControllerRestoreFile(fileRecordId: string, options?: AxiosRequestConfig): AxiosPromise<FileRecordResponse>;

    /**
     * 
     * @summary Streamable upload of a binary file.
     * @param {string} schoolId 
     * @param {string} parentId 
     * @param {'users' | 'schools' | 'courses' | 'tasks' | 'lessons'} parentType 
     * @param {any} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApiInterface
     */
    filesStorageControllerUpload(schoolId: string, parentId: string, parentType: 'users' | 'schools' | 'courses' | 'tasks' | 'lessons', file: any, options?: AxiosRequestConfig): AxiosPromise<FileRecordResponse>;

}

/**
 * FileApi - object-oriented interface
 * @export
 * @class FileApi
 * @extends {BaseAPI}
 */
export class FileApi extends BaseAPI implements FileApiInterface {
    /**
     * 
     * @summary Copy all files of a parent entityId to a target entitId
     * @param {string} schoolId 
     * @param {string} parentId 
     * @param {'users' | 'schools' | 'courses' | 'tasks' | 'lessons'} parentType 
     * @param {CopyFilesOfParentParams} copyFilesOfParentParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesStorageControllerCopy(schoolId: string, parentId: string, parentType: 'users' | 'schools' | 'courses' | 'tasks' | 'lessons', copyFilesOfParentParams: CopyFilesOfParentParams, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).filesStorageControllerCopy(schoolId, parentId, parentType, copyFilesOfParentParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Copy a single file in the same target entityId scope.
     * @param {string} fileRecordId 
     * @param {CopyFileParams} copyFileParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesStorageControllerCopyFile(fileRecordId: string, copyFileParams: CopyFileParams, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).filesStorageControllerCopyFile(fileRecordId, copyFileParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark all files of a parent entityId for deletion. The files are permanently deleted after a certain time.
     * @param {string} schoolId 
     * @param {string} parentId 
     * @param {'users' | 'schools' | 'courses' | 'tasks' | 'lessons'} parentType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesStorageControllerDelete(schoolId: string, parentId: string, parentType: 'users' | 'schools' | 'courses' | 'tasks' | 'lessons', options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).filesStorageControllerDelete(schoolId, parentId, parentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark a single file for deletion. The files are permanently deleted after a certain time.
     * @param {string} fileRecordId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesStorageControllerDeleteFile(fileRecordId: string, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).filesStorageControllerDeleteFile(fileRecordId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Streamable download of a binary file.
     * @param {string} fileRecordId 
     * @param {string} fileName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesStorageControllerDownload(fileRecordId: string, fileName: string, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).filesStorageControllerDownload(fileRecordId, fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of file meta data of a parent entityId.
     * @param {string} schoolId 
     * @param {string} parentId 
     * @param {'users' | 'schools' | 'courses' | 'tasks' | 'lessons'} parentType 
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesStorageControllerList(schoolId: string, parentId: string, parentType: 'users' | 'schools' | 'courses' | 'tasks' | 'lessons', skip?: number, limit?: number, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).filesStorageControllerList(schoolId, parentId, parentType, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rename a single file.
     * @param {string} fileRecordId 
     * @param {RenameFileParams} renameFileParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesStorageControllerPatchFilename(fileRecordId: string, renameFileParams: RenameFileParams, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).filesStorageControllerPatchFilename(fileRecordId, renameFileParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore all files of a parent entityId that are marked for deletion.
     * @param {string} schoolId 
     * @param {string} parentId 
     * @param {'users' | 'schools' | 'courses' | 'tasks' | 'lessons'} parentType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesStorageControllerRestore(schoolId: string, parentId: string, parentType: 'users' | 'schools' | 'courses' | 'tasks' | 'lessons', options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).filesStorageControllerRestore(schoolId, parentId, parentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a single file that is marked for deletion.
     * @param {string} fileRecordId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesStorageControllerRestoreFile(fileRecordId: string, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).filesStorageControllerRestoreFile(fileRecordId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Streamable upload of a binary file.
     * @param {string} schoolId 
     * @param {string} parentId 
     * @param {'users' | 'schools' | 'courses' | 'tasks' | 'lessons'} parentType 
     * @param {any} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filesStorageControllerUpload(schoolId: string, parentId: string, parentType: 'users' | 'schools' | 'courses' | 'tasks' | 'lessons', file: any, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).filesStorageControllerUpload(schoolId, parentId, parentType, file, options).then((request) => request(this.axios, this.basePath));
    }
}


